This Describes the project objectives and goals for the AI Agent.
From this description along with the coding_standards.md file, the AI should be able to generate code that adheres to the coding standards and project requirements.

# Project Description
The goal of this project is to create a high-performance JSON parsing and serialization library in C++23 that adheres to modern C++ coding standards and best practices. The library should be designed for ease of use, maintainability, and extensibility, with a focus on performance and efficiency. The library should utilize C++23 modules, smart pointers for memory management, STL containers and algorithms, ranges and views, concepts for template constraints, and std::expected for error handling of type Result<T, E>. 
The JSON library should use SIMD optimization where applicable for the utmost speed starting from standard scalar instructions ,SSE, SSE2, AVX, AVX2 and AVX-512 where applicable. We will do the same for ARM architectures where possible using NEON and SVE instructions.

As it should waterfall down to lower instruction sets where the higher vectorization is impossible, it should also have a benchmarking suite to measure performance against other popular JSON libraries like RapidJSON, nlohmann/json, and simdjson. It should be completely cross-platform, because it utilizes standard C++ features and avoids platform-specific dependencies.

The library should be completely thread-safe, to allow being used in multi-threaded applications without synchronisation issues. The library should also be capable of using multithreading to speed up parsing where specified by the user.
Also, as a later addition, the library should be able to use openmp for easy parallelism where applicable.
Where available, the library should also be able to use GPU acceleration using CUDA or OpenCL for parsing and serialization of large JSON documents. The library should be able to parse extremely large JSON files, probably even in the order of terabytes, using memory-mapped files or streaming techniques to avoid loading the entire file into memory at once.
For the extreme cases, it should also be able to use disk-based storage for temporary data during parsing and serialization.
Also, in the case of a distributed system where multiple machines are used to parse and serialize JSON documents, the library should be able to use network communication protocols like MPI, to distribute the workload accross multiple nodes in a cluster.

Also, it should be able to work in embedded systems with limited resources, by providing a lightweight version of the library with reduced features and memory footprint. 

Searching, filtering and querying JSON documents should be made easy using a fluent API design, allowing users to easily navigate and manipulate JSON data structures. They should work the same way similar to LINQ in C#. With similar syntax and ease of use.
The searching and querying features should also be optimized for performance, using indexing and caching techniques where applicable. They should work the same way whether it's a single thread, multi-threaded, or distributed system.

The library should be able to serialize and deserialize JSON data to and from C++ objects using a reflection-based approach, allowing users to easily map JSON data to their own custom data structures. The reflection system should be designed to be extensible, allowing users to define their own custom serialization and deserialization rules where necessary. The serialization and deserialization features should work transparently with the parsing and querying features, allowing users to easily convert between JSON data and C++ objects. Also seamlessly between single-threaded, multi-threaded, and distributed systems.

The library should be able to read files accross file sytems boundaries and across different operating systems, handling different file encodings and line endings transparently. It should also be able to read from various data sources like memory buffers, network streams, and standard input/output streams. It should also be able to write to various data sinks like memory buffers, network streams, and standard input/output streams. It should also be able to handle different character encodings like UTF-8, UTF-16, and ASCII transparently. Although we would prefer UTF-8 as the default encoding for maximum compatibility. It should be able to read from distributed file systems like HDFS, GlusterFS, and Ceph, allowing users to easily parse and serialize JSON documents stored in these systems.

All code should undergo rigorous testing, validation, benchmarking and regression testing to ensure correctness, performance, and stability. The library should be well-documented, with clear and concise API documentation, usage examples, and tutorials to help users get started quickly. The documentation should also include performance benchmarks and comparisons with other popular JSON libraries.

For the distributed system features, the library should be able to use network communication protocols like MPI, gRPC, or ZeroMQ or raw sockets to distribute the workload across multiple nodes in a cluster. The distributed system features should be designed to be fault-tolerant, allowing the system to recover from node failures and network interruptions seamlessly. The software should be able to work across a kubernetes cluster or across any sort of container cluster, openshift,kvm etc.
 The distributed system features should also be optimized for performance, using techniques like data partitioning, load balancing, and caching where applicable. With even cluster setup features using ansible scripts to easily set up and configure clusters for distributed JSON parsing and serialization.

We will standardise on Clang++ on Linux for our development and testing environment initially. We will also use MSVC on Windows as our secondary development and testing environment to ensure cross-platform compatibility. Using Clang21 for development along with clang-tidy and clang-format, we will also install clang OpenMP support for parallelism for our development and testing. We will initially standardise on OpenMPI, followed by gRPC and Kafka for the distributed environment. We will also use CMake as our build system to ensure cross-platform compatibility and ease of use. We will use valgrind and sanitizers for memory leak detection and debugging during development and testing.
The JSON parsing and serialization.

Application will use various C++ performance primitives like Copy on Write, move semantics, perfect forwarding, and zero-cost abstractions to ensure maximum performance and efficiency. The library will also utilize advanced C++ features like coroutines, concepts, and constexpr where applicable to enhance performance and usability. Even lock-free data structures and algorithms where applicable for maximum concurrency and throughput.

As an added feature, the library should also have a simulator class that shows the flow of results from the logger, as in the logger should log to the simulator class which will show the logs in a GUI window, the GUI framework to be used is ImGui. So we can see the logs not only in the console but in a GUI window as well and so we can see the computation flow of a component or logger visually, meaning the simulator class should have a visual representation of the flow of data through the logger and other components, showing how data is processed and logged step by step.

The json library will also be able to parse multiple JSON documents and combine them into a single JSON document, allowing users to easily merge and aggregate JSON data from multiple sources. The library should also be able to split a single JSON document into multiple smaller JSON documents, allowing users to easily partition and distribute JSON data across multiple systems. By use of a well-defined API, users should be able to easily combine and split JSON documents using simple and intuitive function calls. For example Combine(jsonDoc1).With(jsonDoc2).And(jsonDoc3).Into(mergedJsonDoc); or some for of mapping function in like map(jsonDoc).SplitBy(criteria).Into(listOfJsonDocs); or standard map-reduce style functions. That can map a single document into multiple and reduce multiple documents into a single one.

The final deliverable should be a high-performance, feature-rich JSON parsing and serialization library in C++23 that adheres to modern C++ coding standards and best practices, with comprehensive documentation, testing, and benchmarking to ensure correctness, performance, and stability.